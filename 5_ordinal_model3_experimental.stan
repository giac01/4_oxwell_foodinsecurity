// Model 3 - Year, ethnicity, gender Random effects. 
// NO Centering or QR decomposition! 
// Tried to make this more streamlined! (removed M_1,)
// DIRICHLET PRIOR PARAMETERISATION
// adapted from code generated by brms 2.19.0
functions {
 /* compute correlated group-level effects
  * Args:
  *   z: matrix of unscaled group-level effects
  *   SD: vector of standard deviation parameters
  *   L: cholesky factor correlation matrix
  * Returns:
  *   matrix of scaled group-level effects
  */
  matrix scale_r_cor(matrix z, vector SD, matrix L) {
    // r is stored in another dimension order than z
    return transpose(diag_pre_multiply(SD, L) * z);
  }
  /* cumulative-logit log-PDF for a single response
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   disc: discrimination parameter
   *   thres: ordinal thresholds
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real cumulative_logit_lpmf(int y, real mu, real disc, vector thres) {
     int nthres = num_elements(thres);
     if (y == 1) {
       return log_inv_logit(disc * (thres[1] - mu));
     } else if (y == nthres + 1) {
       return log1m_inv_logit(disc * (thres[nthres] - mu));
     } else {
       return log_diff_exp(
         log_inv_logit(disc * (thres[y] - mu)), 
         log_inv_logit(disc * (thres[y - 1] - mu))
       );
     }
   }
  /* cumulative-logit log-PDF for a single response and merged thresholds
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   disc: discrimination parameter
   *   thres: vector of merged ordinal thresholds
   *   j: start and end index for the applid threshold within 'thres'
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real cumulative_logit_merged_lpmf(int y, real mu, real disc, vector thres, int[] j) {
     return cumulative_logit_lpmf(y | mu, disc, thres[j[1]:j[2]]);
   }
  /* ordered-logistic log-PDF for a single response and merged thresholds
   * Args:
   *   y: response category
   *   mu: latent mean parameter
   *   thres: vector of merged ordinal thresholds
   *   j: start and end index for the applid threshold within 'thres'
   * Returns:
   *   a scalar to be added to the log posterior
   */
   real ordered_logistic_merged_lpmf(int y, real mu, vector thres, int[] j) {
     return ordered_logistic_lpmf(y | mu, thres[j[1]:j[2]]);
   }
}
data {
  int<lower=1> N;                 // total number of observations
  int          Y[N];              // response variable
  int<lower=2> nthres;            // number of thresholds
  int<lower=1> K;                 // number of fixed effects
  matrix[N, K] X;                 // Fixed effect design matrix
  // Random Slopes for food insecurity across 3 categories (age/year, ethnicity, gender)
  //int<lower=1> M_1;               // number of coefficients/random effects per level (1 - random intercept)
  int<lower=1> n_random_effects;  // number of coefficients per level (=7)
  int<lower=1> n_re_cors;         // number of group-level correlations  (Number of random effect correlations (7^2-7)/2)
  vector[N]    Z_1_1;             // Vector of ones for random intercept (for schools - identical to below )
  vector[N]    Z_2_1;                // Vector of 1s for random intercept
  vector[N]    Z_2_2;                // X1440_foodpovSome
  vector[N]    Z_2_3;                // X1440_foodpovOften
  vector[N]    Z_2_4;                // X1470_foodpovSome
  vector[N]    Z_2_5;                // X1470_foodpovOften
  vector[N]    Z_2_6;                // X1500_foodpovSome
  vector[N]    Z_2_7;                // X1500_foodpovOften
  // Age (or Year-Group) Random Effects 
  int<lower=1> N_1;               // number of grouping levels (# schools)
  int<lower=1> N_2;               // number of distinct grouping levels at level 2 (e.g., number of school years)
  int<lower=1> N_3;               // number of distinct grouping levels at level 3 (e.g., number of ethnicity)
  int<lower=1> N_4;               // number of distinct grouping levels at level 4 (e.g., number of gender groups)

  int<lower=1> J_1[N];            // grouping indicator per observation (SCHOOL ID)
  int<lower=1> J_2[N];            // group membership variable (AGE/YEAR-GROUP)
  int<lower=1> J_3[N];            // group membership variable (Ethnicity)
  int<lower=1> J_4[N];            // group membership variable (Gender)
  int prior_only;                 // should the likelihood be ignored?
  real<lower = 0> conc;           // concentration prior for dirichlet_lpdf(pi | rep_vector(conc, k))
  
}
parameters {
  // Fixed Effects
  vector[K] b;                                 // fixed effects
  simplex[nthres+1] pi;  					             // category probabilities for a person w/ average predictors
  // Varying/Random Effects 
  // school ID 
  real<lower=0> sd_1;                          // group-level standard deviations
  vector[N_1] z_1;                             // standardized group-level effects
  // School-Year
  vector<lower=0>[n_random_effects] sd_2;      // group-level standard deviations
  matrix[n_random_effects, N_2] z_2;           // standardized group-level effects
  cholesky_factor_corr[n_random_effects] L_2;  // cholesky factor of correlation matrix
  // Ethnicity 
  vector<lower=0>[n_random_effects] sd_3;      // group-level standard deviations
  matrix[n_random_effects, N_3] z_3;           // standardized group-level effects
  cholesky_factor_corr[n_random_effects] L_3;  // cholesky factor of correlation matrix
  // Gender 
  vector<lower=0>[n_random_effects] sd_4;      // group-level standard deviations
  matrix[n_random_effects, N_4] z_4;           // standardized group-level effects
  cholesky_factor_corr[n_random_effects] L_4;  // cholesky factor of correlation matrix
  
}
transformed parameters {
  real disc = 1;                  // discrimination parameters
  vector[N_1] r_1_1;              // unstandardized actual group-level effects
  matrix[N_2, n_random_effects] r_2;           // unstandardized actual group-level effects - using vectors speeds up indexing in loops
  vector[N_2] r_2_1;
  vector[N_2] r_2_2;
  vector[N_2] r_2_3;
  vector[N_2] r_2_4;
  vector[N_2] r_2_5;
  vector[N_2] r_2_6;
  vector[N_2] r_2_7;
  
  matrix[N_3, n_random_effects] r_3;           
  vector[N_3] r_3_1;
  vector[N_3] r_3_2;
  vector[N_3] r_3_3;
  vector[N_3] r_3_4;
  vector[N_3] r_3_5;
  vector[N_3] r_3_6;
  vector[N_3] r_3_7;
  
  matrix[N_4, n_random_effects] r_4;           
  vector[N_4] r_4_1;
  vector[N_4] r_4_2;
  vector[N_4] r_4_3;
  vector[N_4] r_4_4;
  vector[N_4] r_4_5;
  vector[N_4] r_4_6;
  vector[N_4] r_4_7;
  
  real lprior = 0;                // prior contributions to the log posterior
  ordered[nthres] Intercept;      // temporary thresholds for centered predictors
  for (j in 1:nthres) Intercept[j] = logit(sum(pi[1:j])); 			// predictors are CENTERED
  // compute actual group-level effects (school)
  r_1_1 = (sd_1 * (z_1));
  // compute actual group-level effects (age)
  r_2 = scale_r_cor(z_2, sd_2, L_2);
  r_2_1 = r_2[, 1];
  r_2_2 = r_2[, 2];
  r_2_3 = r_2[, 3];
  r_2_4 = r_2[, 4];
  r_2_5 = r_2[, 5];
  r_2_6 = r_2[, 6];
  r_2_7 = r_2[, 7];
  // Ethnicity 
  r_3 = scale_r_cor(z_3, sd_3, L_3);
  r_3_1 = r_3[, 1];
  r_3_2 = r_3[, 2];
  r_3_3 = r_3[, 3];
  r_3_4 = r_3[, 4];
  r_3_5 = r_3[, 5];
  r_3_6 = r_3[, 6];
  r_3_7 = r_3[, 7];
  // Gender 
  r_4 = scale_r_cor(z_4, sd_4, L_4);
  r_4_1 = r_4[, 1];
  r_4_2 = r_4[, 2];
  r_4_3 = r_4[, 3];
  r_4_4 = r_4[, 4];
  r_4_5 = r_4[, 5];
  r_4_6 = r_4[, 6];
  r_4_7 = r_4[, 7];
  
  
  // lprior += student_t_lpdf(Intercept | 3, 0, 2.5);
  lprior += dirichlet_lpdf(pi | rep_vector(conc, nthres+1));
  lprior += student_t_lpdf(sd_1 | 3, 0, 2.5) - 1 * student_t_lccdf(0 | 3, 0, 2.5);
  lprior += student_t_lpdf(sd_2 | 3, 0, 2.5) - 7 * student_t_lccdf(0 | 3, 0, 2.5);
  lprior += lkj_corr_cholesky_lpdf(L_2 | 1);
  lprior += student_t_lpdf(sd_3 | 3, 0, 2.5) - 7 * student_t_lccdf(0 | 3, 0, 2.5);
  lprior += lkj_corr_cholesky_lpdf(L_3 | 1);
  lprior += student_t_lpdf(sd_4 | 3, 0, 2.5) - 7 * student_t_lccdf(0 | 3, 0, 2.5);
  lprior += lkj_corr_cholesky_lpdf(L_4 | 1);
  
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] mu = rep_vector(0.0, N);
    mu += X * b;
    for (n in 1:N) {
      // add more terms to the linear predictor
        // r_1_1 = rand coef   obs predictor 
        //  J_2/J_1 = Grouping indicator 
      mu[n] += r_1_1[J_1[n]] * Z_1_1[n] +           // School random intercept
               r_2_1[J_2[n]] * Z_2_1[n] +           // Schoool-Year/Age Random Intercept
               r_2_2[J_2[n]] * Z_2_2[n] +           // X1440_foodpovSome
               r_2_3[J_2[n]] * Z_2_3[n] +           // X1440_foodpovOften
               r_2_4[J_2[n]] * Z_2_4[n] +           // X1470_foodpovSome
               r_2_5[J_2[n]] * Z_2_5[n] +           // X1470_foodpovOften
               r_2_6[J_2[n]] * Z_2_6[n] +           // X1500_foodpovSome
               r_2_7[J_2[n]] * Z_2_7[n] +           // X1500_foodpovOften
               
               r_3_1[J_3[n]] * Z_2_1[n] +           // ETHNICITY EFFECTS (intercept)
               r_3_2[J_3[n]] * Z_2_2[n] +           // X1440_foodpovSome
               r_3_3[J_3[n]] * Z_2_3[n] +           // X1440_foodpovOften
               r_3_4[J_3[n]] * Z_2_4[n] +           // X1470_foodpovSome
               r_3_5[J_3[n]] * Z_2_5[n] +           // X1470_foodpovOften
               r_3_6[J_3[n]] * Z_2_6[n] +           // X1500_foodpovSome
               r_3_7[J_3[n]] * Z_2_7[n] +            // X1500_foodpovOften
               
               r_4_1[J_4[n]] * Z_2_1[n] +           // ETHNICITY EFFECTS (intercept)
               r_4_2[J_4[n]] * Z_2_2[n] +           // X1440_foodpovSome
               r_4_3[J_4[n]] * Z_2_3[n] +           // X1440_foodpovOften
               r_4_4[J_4[n]] * Z_2_4[n] +           // X1470_foodpovSome
               r_4_5[J_4[n]] * Z_2_5[n] +           // X1470_foodpovOften
               r_4_6[J_4[n]] * Z_2_6[n] +           // X1500_foodpovSome
               r_4_7[J_4[n]] * Z_2_7[n];            // X1500_foodpovOften
    }
    for (n in 1:N) {
      target += ordered_logistic_lpmf(Y[n] | mu[n], Intercept);
    }
  }
  // priors including constants
  target += lprior;
  target += std_normal_lpdf(z_1);
  target += std_normal_lpdf(to_vector(z_2));
  target += std_normal_lpdf(to_vector(z_3));
  target += std_normal_lpdf(to_vector(z_4));
}
generated quantities {
  // compute actual thresholds
  vector[nthres] b_Intercept = Intercept;
  // compute group-level correlations
  corr_matrix[n_random_effects] Cor_2 = multiply_lower_tri_self_transpose(L_2);
  corr_matrix[n_random_effects] Cor_3 = multiply_lower_tri_self_transpose(L_3);
  corr_matrix[n_random_effects] Cor_4 = multiply_lower_tri_self_transpose(L_4);
  vector<lower=-1,upper=1>[n_re_cors] cor_2;
  vector<lower=-1,upper=1>[n_re_cors] cor_3;
  vector<lower=-1,upper=1>[n_re_cors] cor_4;

  
  // extract upper diagonal of correlation matrix
  for (k in 1:n_random_effects) {
    for (j in 1:(k - 1)) {
      cor_2[choose(k - 1, 2) + j] = Cor_2[j, k];
    }
  }
  // extract upper diagonal of correlation matrix
  for (k in 1:n_random_effects) {
    for (j in 1:(k - 1)) {
      cor_3[choose(k - 1, 2) + j] = Cor_3[j, k];
    }
  }
  // extract upper diagonal of correlation matrix
  for (k in 1:n_random_effects) {
    for (j in 1:(k - 1)) {
      cor_4[choose(k - 1, 2) + j] = Cor_4[j, k];
    }
  }
}
